[
["index.html", "Tidy evaluation 欢迎 Other resources", " Tidy evaluation Lionel Henry Hadley Wickham 王诗翔（译） 欢迎 The primary goal of this book is to get you up to speed with tidy evaluation by showing you how to write functions using tidyverse pipelines and grammars. The book is written and organised so that you can quickly find the information you need to solve real world problems without having to “get” tidy eval first: The first chapter Getting up to speed is a quick introduction to the main pattern used in all tidy eval functions: quote and unquote. The Cookbooks sections are organised by common tasks for the dplyr and ggplot2 packages. Though this is a work in progress, we hope you’ll find this bookdown valuable for programming with tidyverse interfaces. Other resources You may also be interested in: “Tidy eval in 5 minutes” is a quick 5 minutes video that explains the big ideas behind tidy evaluation. It’s a great way to get an overview of concepts before diving in other tutorials. “Tidy eval webinar” is a one hour tutorial video on tidy evaluation. “The second edition of Advanced R” which includes a whole chapter on meta programming with tidy eval. "],
["introduction.html", "1 Introduction", " 1 Introduction Tidyverse grammars, like dplyr, have a distinctive look and feel. This is in part because they are designed to follow a set of principles. The most important feature of tidyverse grammars is that they let you work with your data as if they were actual objects in your workspace. In a way, the data frame itself becomes a (temporary) workspace. Data masking makes it easy and natural to read and write data manipulation code, but it has a flip side. It is easier to refer to objects in the mask when you know their names in advance, but it is harder when the names are unknown at the time of writing. In particular, it is harder to make indirect references with column names stored in variables or passed as function arguments. Tidy evaluation is a set of concepts and tools that make it possible to use tidyverse grammars when columns are specified indirectly. In particular, you will need to learn some tidy eval to extract a tidyverse pipeline in a reusable function. The first chapter Why and how provides the motivation for tidy eval, presents the problems that it poses in day-to-day programming, and the general theory and tools for solving those. If you are in a hurry, you can jump straight to Do you need tidy eval?. A lot can be done without writing a single line of tidy eval! If you are positive you need it to solve your problem, Getting up to speed is a self-contained chapter that will teach you the basic workflow of wrapping a tidyverse pipeline in a reusable function. The book ends with a series of recipes and idioms for solving various dplyr and ggplot2 problems. "],
["sec-why-how.html", "2 Why and how 2.1 Data masking 2.2 Quoting code 2.3 Unquoting code", " 2 Why and how Tidy evaluation is a framework for metaprogramming in R, used throughout the tidyverse to implement data masking. Metaprogramming is about using a programming language to manipulate or modify its own code. This idea is used throughout the tidyverse to change the context of computation of certain pieces of R code. Changing the context of evaluation is useful for four main purposes: To promote data frames to full blown scopes, where columns are exposed as named objects. To execute your R code in a foreign environment. For instance, dbplyr translates ordinary dplyr pipelines to SQL queries. To execute your R code with a more performant compiled language. For instance, the dplyr package uses C++ implementations for a certain set of mathematical expressions to avoid executing slower R code when possible1. To implement special rules for ordinary R operators. For instance, selection functions such as dplyr::select() or tidyr::gather() implement specific behaviours for c(), : and -. 2.1 Data masking Of these goals, the promotion of data frames is the most important because data is often the most relevant context for data analysts. We believe that R and the tidyverse are human-centered in big part because the data frame is available for direct use in computations, without syntax and boilerplate getting in the way. Formulas for statistical models are a prime example of human-centered syntax in R. Data masking and special operator rules make model formulas an intuitive interface for model specification. When the contents of the data frame are temporarily promoted as first class objects, we say the data masks the workspace: library(&quot;dplyr&quot;) starwars %&gt;% filter( height &lt; 200, gender == &quot;male&quot; ) Data masking is natural in R because it reduces boilerplate and results in code that maps more directly to how users think about data manipulation problems. Compare to the equivalent subsetting code where it is necessary to be explicit about where the columns come from: starwars[starwars$height &lt; 200 &amp; starwars$gender == &quot;male&quot;, ] Data masking is only possible because R allows suspending the normal flow of evaluation. If code was evaluated in the normal way, R would not be able to find the relevant columns for the computation. For instance, a normal function like list(), which has no concept of data masking, will give an error about object not found: list( height &lt; 200, gender == &quot;male&quot; ) #&gt; Error in eval(expr, envir, enclos): 找不到对象&#39;height&#39; 2.2 Quoting code In order to change the context, evaluation must first be suspended before being resumed in a different environment. The technical term for delaying code in this way is quoting. Tidyverse grammars quote the code supplied by users as arguments. They don’t get results of code but the quoted code itself, whose evaluation can be resumed later on in a data context. In a way, quoted code is like a blueprint for R computations. One important quoting function in dplyr is vars(). This function does nothing but return its arguments as blueprints to be interpreted later on by verbs like summarise_at(): starwars %&gt;% summarise_at(vars(ends_with(&quot;color&quot;)), n_distinct) #&gt; # A tibble: 1 x 3 #&gt; hair_color skin_color eye_color #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 13 31 15 If you call vars() alone, you get to see the blueprints! 2 vars( ends_with(&quot;color&quot;), height:mass ) #&gt; &lt;list_of&lt;quosure&gt;&gt; #&gt; #&gt; [[1]] #&gt; &lt;quosure&gt; #&gt; expr: ^ends_with(&quot;color&quot;) #&gt; env: global #&gt; #&gt; [[2]] #&gt; &lt;quosure&gt; #&gt; expr: ^height:mass #&gt; env: global The evaluation of an expression captured as a blueprint can be resumed at any time, possibly in a different context: exprs &lt;- vars(height / 100, mass + 50) rlang::eval_tidy(exprs[[1]]) #&gt; Error in rlang::eval_tidy(exprs[[1]]): 找不到对象&#39;height&#39; rlang::eval_tidy(exprs[[1]], data = starwars) #&gt; [1] 1.72 1.67 0.96 2.02 1.50 1.78 1.65 0.97 1.83 1.82 1.88 1.80 2.28 1.80 #&gt; [15] 1.73 1.75 1.70 1.80 0.66 1.70 1.83 2.00 1.90 1.77 1.75 1.80 1.50 NA #&gt; [29] 0.88 1.60 1.93 1.91 1.70 1.96 2.24 2.06 1.83 1.37 1.12 1.83 1.63 1.75 #&gt; [43] 1.80 1.78 0.94 1.22 1.63 1.88 1.98 1.96 1.71 1.84 1.88 2.64 1.88 1.96 #&gt; [57] 1.85 1.57 1.83 1.83 1.70 1.66 1.65 1.93 1.91 1.83 1.68 1.98 2.29 2.13 #&gt; [71] 1.67 0.79 0.96 1.93 1.91 1.78 2.16 2.34 1.88 1.78 2.06 NA NA NA #&gt; [85] NA NA 1.65 To sum up, the distinctive look and feel of data masking UIs requires suspending the normal evaluation of R code. Once captured as quoted code, it can be resumed in a different context. Unfortunately, the delaying of code makes it harder to program with data masking functions, and requires learning a bit of new theory and some new tools. 2.3 Unquoting code Data masking functions prevent the normal evaluation of their arguments by quoting them. Once in possession of the blueprints of their arguments, a data mask is created and the evaluation is resumed in this new context. Unfortunately, delaying code in this way has a flip side. While it is natural to substitute values when you’re programming with normal functions using regular evaluation, it is harder to substitute column names in data masking functions that delay evaluation of your code. To make indirect references to columns, it is necessary to modify the quoted code before it gets evaluated. This is exactly what the !! operator, pronounced bang bang, is all about. It is a surgery operator for blueprints of R code. In the world of normal functions, making indirect references to values is easy. Expressions that yield the same values can be freely interchanged, a property that is sometimes called referential transparency. The following calls to my_function() all yield the same results because they were given the same value as inputs: my_function &lt;- function(x) x * 100 my_function(6) #&gt; [1] 600 my_function(2 * 3) #&gt; [1] 600 a &lt;- 2 b &lt;- 3 my_function(a * b) #&gt; [1] 600 Because data masking functions evaluate their quoted arguments in a different context, they do not have this property: starwars %&gt;% summarise(avg = mean(height, na.rm = TRUE)) #&gt; # A tibble: 1 x 1 #&gt; avg #&gt; &lt;dbl&gt; #&gt; 1 174. value &lt;- mean(height, na.rm = TRUE) #&gt; Error in mean(height, na.rm = TRUE): 找不到对象&#39;height&#39; starwars %&gt;% summarise(avg = value) #&gt; Error: 找不到对象&#39;value&#39; Storing a column name in a variable or passing one as a function argument requires the tidy eval operator !!. This special operator, only available in quoting functions, acts like a surgical operator for modifying blueprints. To understand what it does, it is best to see it in action. The qq_show() helper from rlang processes !! and prints the resulting blueprint of the computation. As you can observe, !! modifies the quoted code by inlining the value of its operand right into the blueprint: x &lt;- 1 rlang::qq_show( starwars %&gt;% summarise(out = x) ) #&gt; starwars %&gt;% summarise(out = x) rlang::qq_show( starwars %&gt;% summarise(out = !!x) ) #&gt; starwars %&gt;% summarise(out = 1) What would it take to create an indirect reference to a column name? Inlining the name as a string in the blueprint will not produce what you expect: col &lt;- &quot;height&quot; rlang::qq_show( starwars %&gt;% summarise(out = sum(!!col, na.rm = TRUE)) ) #&gt; starwars %&gt;% summarise(out = sum(&quot;height&quot;, na.rm = TRUE)) This code amounts to taking the mean of a string, something that R will not be happy about: starwars %&gt;% summarise(out = sum(&quot;height&quot;, na.rm = TRUE)) #&gt; Error in sum(&quot;height&quot;, na.rm = TRUE): &#39;type&#39;(character)参数不对 To refer to column names inside a blueprint, we need to inline blueprint material. We need symbols: sym(col) #&gt; height Symbols are a special type of string that represent other objects. When a piece of R code is evaluated, every bare variable name is actually a symbol that represents some value, as defined in the current context. Let’s see what the modified blueprint looks like when we inline a symbol: rlang::qq_show( starwars %&gt;% summarise(out = sum(!!sym(col), na.rm = TRUE)) ) #&gt; starwars %&gt;% summarise(out = sum(height, na.rm = TRUE)) Looks good! We’re now ready to actually run the dplyr pipeline with an indirect reference: starwars %&gt;% summarise(out = sum(!!sym(col), na.rm = TRUE)) #&gt; # A tibble: 1 x 1 #&gt; out #&gt; &lt;int&gt; #&gt; 1 14123 There were two necessary steps to create an indirect reference and properly modify the summarising code: We first created a piece of blueprint (a symbol) with sym(). We used !! to insert it in the blueprint captured by summarise(). We call the combination of these two steps the quote and unquote pattern. This pattern is the heart of programming with tidy eval functions. We quote an expression and unquote it in another quoted expression. In other words, we create or capture a piece of blueprint, and insert it in another blueprint just before it’s captured by a data masking function. This process is also called interpolation. Most of the time though, we don’t need to create blueprints manually. We’ll get them by quoting the arguments supplied by users. This gives your functions the same usage and feel as tidyverse verbs. The data.table package uses different metaprogramming tools than tidy eval for the same purpose. Certain expressions are executed in C to perform efficient data transformations.↩ As you can see, these blueprints are also called quosures. These are special types of expressions that keep track of the current context, or environment.↩ "],
["sec-do-you-need.html", "3 Do you need tidy eval? 3.1 Fixed column names 3.2 Automating loops", " 3 Do you need tidy eval? In computer science, frameworks like tidy evaluation are known as metaprogramming. Modifying the blueprints of computations amounts to programming the program, i.e. metaprogramming. In other languages, this type of approach is often seen as a last resort because it requires new skills and might make your code harder to read. Things are different in R because of the importance of data masking functions, but it is still good advice to consider other options before turning to tidy evaluation. In this section, we review several strategies for solving programming problems with tidyverse packages. Before diving into tidy eval, make sure to know about the fundamentals of programming with the tidyverse. These are likely to have a better return on investment of time and will also be useful to solve problems outside the tidyverse. Fixed column names. A solid function taking data frames with fixed column names is better than a brittle function that uses tidy eval. Automating loops. dplyr excels at automating loops. Acquiring a good command of rowwise vectorisation and columnwise mapping may prove very useful. Tidy evaluation is not all-or-nothing, it encompasses a wide range of features and techniques. Here are a few techniques that are easy to pick up in your workflow: Passing expressions through {{ and .... Passing column names to .data[[ and one_of(). All these techniques make it possible to reuse existing components of tidyverse grammars and compose them into new functions. 3.1 Fixed column names A simple solution is to write functions that expect data frames containing specific column names. If the computation always operates on the same columns and nothing varies, you don’t need any tidy eval. On the other hand, your users must ensure the existence of these columns as part of their data cleaning process. This is why this technique primarily makes sense when you’re writing functions tailored to your own data analysis uses, or perhaps in functions that interface with a specific web API for retrieving data. In general, fixed column names are task specific. Say we have a simple pipeline that computes the body mass index for each observation in a tibble: starwars %&gt;% transmute(bmi = mass / (height / 100)^2) #&gt; # A tibble: 87 x 1 #&gt; bmi #&gt; &lt;dbl&gt; #&gt; 1 26.0 #&gt; 2 26.9 #&gt; 3 34.7 #&gt; 4 33.3 #&gt; 5 21.8 #&gt; # … with 82 more rows We could extract this code in a function that takes data frames with columns mass and height: compute_bmi &lt;- function(data) { data %&gt;% transmute(bmi = mass / height^2) } It’s always a good idea to check the inputs of your functions and fail early with an informative error message when their assumptions are not met. In this case, we should validate the data frame and throw an error when it does not contain the expected columns: compute_bmi &lt;- function(data) { if (!all(c(&quot;mass&quot;, &quot;height&quot;) %in% names(data))) { stop(&quot;`data` must contain `mass` and `height` columns&quot;) } data %&gt;% transmute(bmi = mass / height^2) } iris %&gt;% compute_bmi() #&gt; Error in compute_bmi(.): `data` must contain `mass` and `height` columns In fact, we could go even further and validate the contents of the columns in addition to their names: compute_bmi &lt;- function(data) { if (!all(c(&quot;mass&quot;, &quot;height&quot;) %in% names(data))) { stop(&quot;`data` must contain `mass` and `height` columns&quot;) } mean_height &lt;- round(mean(data$height, na.rm = TRUE), 1) if (mean_height &gt; 3) { warning(glue::glue( &quot;Average height is { mean_height }, is it scaled in meters?&quot; )) } data %&gt;% transmute(bmi = mass / height^2) } starwars %&gt;% compute_bmi() #&gt; Warning in compute_bmi(.): Average height is 174.4, is it scaled in meters? #&gt; # A tibble: 87 x 1 #&gt; bmi #&gt; &lt;dbl&gt; #&gt; 1 0.00260 #&gt; 2 0.00269 #&gt; 3 0.00347 #&gt; 4 0.00333 #&gt; 5 0.00218 #&gt; # … with 82 more rows starwars %&gt;% mutate(height = height / 100) %&gt;% compute_bmi() #&gt; # A tibble: 87 x 1 #&gt; bmi #&gt; &lt;dbl&gt; #&gt; 1 26.0 #&gt; 2 26.9 #&gt; 3 34.7 #&gt; 4 33.3 #&gt; 5 21.8 #&gt; # … with 82 more rows Spending your programming time on the domain logic of your function, such as input and scale validation, may have a greater payoff than learning tidy eval just to improve its syntax. It makes your function more robust to faulty data and reduces the risks of erroneous analyses. 3.2 Automating loops Most programming problems involve iteration because data transformations are typically achieved element by element, by applying the same recipe over and over again. There are two main ways of automating iteration in R, vectorisation and mapping. Learning how to juggle with the different ways of expressing loops is not only an important step towards acquiring a good command of R and the tidyverse, it will also make you more proficient at solving programming problems. 3.2.1 Vectorisation in dplyr dplyr is designed to optimise iteration by taking advantage of the vectorisation of many R functions. Rowwise vectorisation is achieved through normal R rules, which dplyr augments with groupwise vectorisation. 3.2.1.1 Rowwise vectorisation Rowwise vectorisation in dplyr is a consequence of normal R rules for vectorisation. A vectorised function is a function that works the same way with vectors of 1 element as with vectors of n elements. The operation is applied elementwise (often at the machine code level, which makes them very efficient). We have already mentioned the vectorisation of toupper(), and many other functions in R are vectorised. One important class of vectorised functions is the arithmetic operators: # Dividing 1 element 1 / 10 #&gt; [1] 0.1 # Dividing 5 elements 1:5 / 10 #&gt; [1] 0.1 0.2 0.3 0.4 0.5 Technically, a function is vectorised when: It returns a vector as long as the input. Applying the function on a single element yields the same result than applying it on the whole vector and then subsetting the element. In other words, a vectorised function fn fulfills the following identity: fn(x[[i]]) == fn(x)[[i]] When you mix vectorised and non-vectorised operations, the combined operation is itself vectorised when the last operation to run is vectorised. Here we’ll combine the vectorised / function with the summary function mean(). The result of this operation is a vector that has the same length as the LHS of /: x &lt;- 1:5 x / mean(x) #&gt; [1] 0.33 0.67 1.00 1.33 1.67 Note that the other combination of operations is not vectorised because in that case the summary operation has the last word: mean(x / 10) #&gt; [1] 0.3 The dplyr verb mutate() expects vector semantics. The operations defining new columns typically return vectors as long as their inputs: data &lt;- tibble(x = rnorm(5, sd = 10)) data %&gt;% mutate(rescaled = x / sd(x)) #&gt; # A tibble: 5 x 2 #&gt; x rescaled #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 -14.0 -1.09 #&gt; 2 2.55 0.199 #&gt; 3 -24.4 -1.90 #&gt; 4 -0.0557 -0.00434 #&gt; 5 6.22 0.484 In fact, mutate() enforces vectorisation. Returning a smaller vector is an error unless it has size 1. If the result of a mutate expression has size 1, it is automatically recycled to the tibble or group size. This ensures that all columns have the same length and fit within the tibble constraints of rectangular data: data %&gt;% mutate(sigma = sd(x)) #&gt; # A tibble: 5 x 2 #&gt; x sigma #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 -14.0 12.8 #&gt; 2 2.55 12.8 #&gt; 3 -24.4 12.8 #&gt; 4 -0.0557 12.8 #&gt; 5 6.22 12.8 In contrast to mutate(), the dplyr verb summarise() expects summary operations that return a single value: data %&gt;% summarise(sd(x)) #&gt; # A tibble: 1 x 1 #&gt; `sd(x)` #&gt; &lt;dbl&gt; #&gt; 1 12.8 3.2.1.2 Groupwise vectorisation Things get interesting with grouped tibbles. dplyr augments the vectorisation of normal R functions with groupwise vectorisation. If your tibble has ngroup groups, the operations are repeated ngroup times. my_division &lt;- function(x, y) { message(&quot;I was just called&quot;) x / y } # Called 1 time data %&gt;% mutate(new = my_division(x, 10)) #&gt; I was just called #&gt; # A tibble: 5 x 2 #&gt; x new #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 -14.0 -1.40 #&gt; 2 2.55 0.255 #&gt; 3 -24.4 -2.44 #&gt; 4 -0.0557 -0.00557 #&gt; 5 6.22 0.622 gdata &lt;- data %&gt;% group_by(g = c(&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;)) # Called 3 times gdata %&gt;% mutate(new = my_division(x, 10)) #&gt; I was just called #&gt; I was just called #&gt; I was just called #&gt; # A tibble: 5 x 3 #&gt; # Groups: g [3] #&gt; x g new #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 -14.0 a -1.40 #&gt; 2 2.55 a 0.255 #&gt; 3 -24.4 b -2.44 #&gt; 4 -0.0557 b -0.00557 #&gt; 5 6.22 c 0.622 If the operation is entirely vectorised, the result will be the same whether the tibble is grouped or not, since elementwise computations are not affected by the values of other elements. But as soon as summary operations are involved, the result depends on the grouping structure because the summaries are computed from group sections instead of whole columns. # Marginal rescaling data %&gt;% mutate(new = x / sd(x)) #&gt; # A tibble: 5 x 2 #&gt; x new #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 -14.0 -1.09 #&gt; 2 2.55 0.199 #&gt; 3 -24.4 -1.90 #&gt; 4 -0.0557 -0.00434 #&gt; 5 6.22 0.484 # Conditional rescaling gdata %&gt;% mutate(new = x / sd(x)) #&gt; # A tibble: 5 x 3 #&gt; # Groups: g [3] #&gt; x g new #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 -14.0 a -1.20 #&gt; 2 2.55 a 0.218 #&gt; 3 -24.4 b -1.42 #&gt; 4 -0.0557 b -0.00324 #&gt; 5 6.22 c NA Whereas rowwise vectorisation automates loops over the elements of a column, groupwise vectorisation automates loops over the levels of a grouping specification. The combination of these is very powerful. 3.2.2 Looping over columns Rowwise and groupwise vectorisations are means of looping in the direction of rows, applying the same operation to each group and each element. What if you’d like to apply an operation in the direction of columns? This is possible in dplyr by mapping functions over columns. Mapping functions is part of the functional programming approach. If you’re going to spend some time learning new programming concepts, acquiring functional programming skills is likely to have a higher payoff than learning about the metaprogramming concepts of tidy evaluation. Functional programming is inherent to R as it underlies the apply() family of functions in base R and the map() family from the purrr package. It is a powerful tool to add to your quiver. 3.2.2.1 Mapping functions Everything that exists in R is an object, including functions. If you type the name of a function without parentheses, you get the function object instead of the result of calling the function: toupper #&gt; function (x) #&gt; { #&gt; if (!is.character(x)) #&gt; x &lt;- as.character(x) #&gt; .Internal(toupper(x)) #&gt; } #&gt; &lt;bytecode: 0x7f8dd20ca538&gt; #&gt; &lt;environment: namespace:base&gt; In its simplest form, functional programming is about passing a function object as argument to another function called a mapper function, that iterates over a vector to apply the function on each element, and returns all results in a new vector. In other words, a mapper functions writes loops so you don’t have to. Here is a manual loop that applies toupper() over all elements of a character vector and returns a new vector: new &lt;- character(length(letters)) for (i in seq_along(letters)) { new[[i]] &lt;- toupper(letters[[i]]) } new #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; #&gt; [18] &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; Using a mapper function results in much leaner code. Here we apply toupper() over all elements of letters and return the results as a character vector, as indicated by the suffix _chr: new &lt;- purrr::map_chr(letters, toupper) new #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; #&gt; [18] &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; In practice, functional programming is all about hiding for loops, which are abstracted away by the mapper functions that automate the iteration. Mapping is an elegant way of transforming data element by element, but it’s not the only one. For instance, toupper() is actually a vectorised function that already operates on whole vectors element by element. The fastest and leanest code is just: toupper(letters) #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; #&gt; [18] &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; Mapping functions are more useful with functions that are not vectorised or for computations over lists and data frame columns where the vectorisation occurs within the elements or columns themselves. In the following example, we apply a summarising function over all columns of a data frame: purrr::map_int(mtcars, n_distinct) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; 25 3 27 22 22 29 30 2 2 3 6 3.2.2.2 Scoped dplyr variants dplyr provides variants of the main data manipulation verbs that map functions over a selection of columns. These verbs are known as the scoped variants and are recognizable from their _at, _if and _all suffixes. Scoped verbs support three sorts of selection: _all verbs operate on all columns of the data frame. You can summarise all columns of a data frame within groups with summarise_all(): iris %&gt;% group_by(Species) %&gt;% summarise_all(mean) #&gt; # A tibble: 3 x 5 #&gt; Species Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 setosa 5.01 3.43 1.46 0.246 #&gt; 2 versicolor 5.94 2.77 4.26 1.33 #&gt; 3 virginica 6.59 2.97 5.55 2.03 _if verbs operate conditionally, on all columns for which a predicate returns TRUE. If you are familiar with purrr, the idea is similar to the conditional mapper purrr::map_if(). Promoting all character columns of a data frame as grouping variables is as simple as: starwars %&gt;% group_by_if(is.character) #&gt; # A tibble: 87 x 13 #&gt; # Groups: name, hair_color, skin_color, eye_color, gender, homeworld, #&gt; # species [87] #&gt; name height mass hair_color skin_color eye_color birth_year gender #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 Luke… 172 77 blond fair blue 19 male #&gt; 2 C-3PO 167 75 &lt;NA&gt; gold yellow 112 &lt;NA&gt; #&gt; 3 R2-D2 96 32 &lt;NA&gt; white, bl… red 33 &lt;NA&gt; #&gt; 4 Dart… 202 136 none white yellow 41.9 male #&gt; 5 Leia… 150 49 brown light brown 19 female #&gt; # … with 82 more rows, and 5 more variables: homeworld &lt;chr&gt;, #&gt; # species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; _at verbs operate on a selection of columns. You can supply integer vectors of column positions or character vectors of colunm names. mtcars %&gt;% summarise_at(1:2, mean) #&gt; mpg cyl #&gt; 1 20 6.2 mtcars %&gt;% summarise_at(c(&quot;disp&quot;, &quot;drat&quot;), median) #&gt; disp drat #&gt; 1 196 3.7 More interestingly, you can use vars()3 to supply the same sort of expressions you would pass to select()! The selection helpers make it very convenient to craft a selection of columns to map over. starwars %&gt;% summarise_at(vars(height:mass), mean) #&gt; # A tibble: 1 x 2 #&gt; height mass #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 NA NA starwars %&gt;% summarise_at(vars(ends_with(&quot;_color&quot;)), n_distinct) #&gt; # A tibble: 1 x 3 #&gt; hair_color skin_color eye_color #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 13 31 15 The scoped variants of mutate() and summarise() are the closest analogue to base::lapply() and purrr::map(). Unlike pure list mappers, the scoped verbs fully implement the dplyr semantics, such as groupwise vectorisation or the summary constraints: # map() returns a simple list with the results mtcars[1:5] %&gt;% purrr::map(mean) #&gt; $mpg #&gt; [1] 20 #&gt; #&gt; $cyl #&gt; [1] 6.2 #&gt; #&gt; $disp #&gt; [1] 231 #&gt; #&gt; $hp #&gt; [1] 147 #&gt; #&gt; $drat #&gt; [1] 3.6 # `mutate_` variants recycle to group size mtcars[1:5] %&gt;% mutate_all(mean) #&gt; # A tibble: 32 x 5 #&gt; mpg cyl disp hp drat #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 20.1 6.19 231. 147. 3.60 #&gt; 2 20.1 6.19 231. 147. 3.60 #&gt; 3 20.1 6.19 231. 147. 3.60 #&gt; 4 20.1 6.19 231. 147. 3.60 #&gt; 5 20.1 6.19 231. 147. 3.60 #&gt; # … with 27 more rows # `summarise_` variants enforce a size 1 constraint mtcars[1:5] %&gt;% summarise_all(mean) #&gt; # A tibble: 1 x 5 #&gt; mpg cyl disp hp drat #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 20.1 6.19 231. 147. 3.60 # All scoped verbs know about groups mtcars[1:5] %&gt;% group_by(cyl) %&gt;% summarise_all(mean) #&gt; # A tibble: 3 x 5 #&gt; cyl mpg disp hp drat #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 26.7 105. 82.6 4.07 #&gt; 2 6 19.7 183. 122. 3.59 #&gt; 3 8 15.1 353. 209. 3.23 The other scoped variants also accept optional functions to map over the selection of columns. For instance, you could group by a selection of variables and transform them on the fly: iris %&gt;% group_by_if(is.factor, as.character) #&gt; # A tibble: 150 x 5 #&gt; # Groups: Species [3] #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5 3.6 1.4 0.2 setosa #&gt; # … with 145 more rows or transform the column names of selected variables: storms %&gt;% select_at(vars(name:hour), toupper) #&gt; # A tibble: 10,010 x 5 #&gt; NAME YEAR MONTH DAY HOUR #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Amy 1975 6 27 0 #&gt; 2 Amy 1975 6 27 6 #&gt; 3 Amy 1975 6 27 12 #&gt; 4 Amy 1975 6 27 18 #&gt; 5 Amy 1975 6 28 0 #&gt; # … with 10,005 more rows The scoped variants lie at the intersection of purrr and dplyr and combine the rowwise looping mechanisms of dplyr with the columnwise mapping of purrr. This is a powerful combination. vars() is the function that does the quoting of your expressions, and returns blueprints to its caller. This pattern of letting an external helper quote the arguments is called external quoting.↩ "],
["sec-up-to-speed.html", "4 Getting up to speed 4.1 Writing functions 4.2 Quote and unquote 4.3 Strings instead of quotes", " 4 Getting up to speed While tidyverse grammars are easy to write in scripts and at the console, they make it a bit harder to reduce code duplication. Writing functions around dplyr pipelines and other tidyeval APIs requires a bit of special knowledge because these APIs use a special type of functions called quoting functions in order to make data first class. If one-off code is often reasonable for common data analysis tasks, it is good practice to write reusable functions to reduce code duplication. In this introduction, you will learn about quoting functions, what challenges they pose for programming, and the solutions that tidy evaluation provides to solve those problems. 4.1 Writing functions 4.1.1 Reducing duplication Writing functions is essential for the clarity and robustness of your code. Functions have several advantages: They prevent inconsistencies because they force multiple computations to follow a single recipe. They emphasise what varies (the arguments) and what is constant (every other component of the computation). They make change easier because you only need to modify one place. They make your code clearer if you give the function and its arguments informative names. The process for creating a function is straightforward. First, recognise duplication in your code. A good rule of thumb is to create a function when you have copy-pasted a piece of code three times. Can you spot the copy-paste mistake in this duplicated code? (df$a - min(df$a)) / (max(df$a) - min(df$a)) (df$b - min(df$b)) / (max(df$b) - min(df$b)) (df$c - min(df$c)) / (max(df$c) - min(df$c)) (df$d - min(df$d)) / (max(df$d) - min(df$c)) Now identify the varying parts of the expression and give each a name. x is an easy choice, but it is often a good idea to reflect the type of argument expected in the name. In our case we expect a numeric vector: (num - min(num)) / (max(num) - min(num)) (num - min(num)) / (max(num) - min(num)) (num - min(num)) / (max(num) - min(num)) (num - min(num)) / (max(num) - min(num)) We can now create a function with a relevant name: rescale01 &lt;- function(num) { } Fill it with our deduplicated code: rescale01 &lt;- function(num) { (num - min(num)) / (max(num) - min(num)) } And refactor a little to reduce duplication further and handle more cases: rescale01 &lt;- function(num) { rng &lt;- range(num, na.rm = TRUE, finite = TRUE) (num - rng[[1]]) / (rng[[2]] - rng[[1]]) } Now you can reuse your function any place you need it: rescale01(df$a) rescale01(df$b) rescale01(df$c) rescale01(df$d) Reducing code duplication is as much needed with tidyverse grammars as with ordinary computations. Unfortunately, the straightforward process to create functions breaks down with grammars like dplyr, which we attach now. library(&quot;dplyr&quot;) To see the problem, let’s use the same function-writing process with a duplicated dplyr pipeline: df1 %&gt;% group_by(x1) %&gt;% summarise(mean = mean(y1)) df2 %&gt;% group_by(x2) %&gt;% summarise(mean = mean(y2)) df3 %&gt;% group_by(x3) %&gt;% summarise(mean = mean(y3)) df4 %&gt;% group_by(x4) %&gt;% summarise(mean = mean(y4)) We first abstract out the varying parts by giving them informative names: data %&gt;% group_by(group_var) %&gt;% summarise(mean = mean(summary_var)) And wrap the pipeline with a function taking these argument names: grouped_mean &lt;- function(data, group_var, summary_var) { data %&gt;% group_by(group_var) %&gt;% summarise(mean = mean(summary_var)) } Unfortunately this function doesn’t actually work. When you call it dplyr complains that the variable group_var is unknown: grouped_mean(mtcars, cyl, mpg) #&gt; Error: Column `group_var` is unknown Here is the proper way of defining this function: grouped_mean &lt;- function(data, group_var, summary_var) { group_var &lt;- enquo(group_var) summary_var &lt;- enquo(summary_var) data %&gt;% group_by(!!group_var) %&gt;% summarise(mean = mean(!!summary_var)) } grouped_mean(mtcars, cyl, mpg) #&gt; # A tibble: 3 x 2 #&gt; cyl mean #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 26.7 #&gt; 2 6 19.7 #&gt; 3 8 15.1 To understand how that works, we need to learn about quoting functions and what special steps are needed to be effective at programming with them. Really we only need two new concepts forming together a single pattern: quoting and unquoting. This introduction will get you up to speed with this pattern. 4.1.2 What’s special about quoting functions? R functions can be categorised in two broad categories: evaluating functions and quoting functions 4. These functions differ in the way they get their arguments. Evaluating functions take arguments as values. It does not matter what the expression supplied as argument is or which objects it contains. R computes the argument value following the standard rules of evaluation which the function receives passively 5. The simplest regular function is identity(). It evaluates its single argument and returns the value. Because only the final value of the argument matters, all of these statements are completely equivalent: identity(6) #&gt; [1] 6 identity(2 * 3) #&gt; [1] 6 a &lt;- 2 b &lt;- 3 identity(a * b) #&gt; [1] 6 On the other hand, a quoting function is not passed the value of an expression, it is passed the expression itself. We say the argument has been automatically quoted. The quoted expression might be evaluated a bit later or might not be evaluated at all. The simplest quoting function is quote(). It automatically quotes its argument and returns the quoted expression without any evaluation. Because only the expression passed as argument matters, none of these statements are equivalent: quote(6) #&gt; [1] 6 quote(2 * 3) #&gt; 2 * 3 quote(a * b) #&gt; a * b Other familiar quoting operators are &quot;&quot; and ~. The &quot;&quot; operator quotes a piece of text at parsing time and returns a string. This prevents the text from being interpreted as some R code to evaluate. The tilde operator is similar to the quote() function in that it prevents R code from being automatically evaluated and returns a quoted expression in the form of a formula. The expression is then used to define a statistical model in modelling functions. The three following expressions are doing something similar, they are quoting their input: &quot;a * b&quot; #&gt; [1] &quot;a * b&quot; ~ a * b #&gt; ~a * b quote(a * b) #&gt; a * b The first statement returns a quoted string and the other two return quoted code in a formula or as a bare expression. 4.1.2.1 Quoting and evaluating in mundane R code As an R programmer, you are probably already familiar with the distinction between quoting and evaluating functions. Take the case of subsetting a data frame column by name. The [[ and $ operators are both standard for this task but they are used in very different situations. The former supports indirect references like variables or expressions that represent a column name while the latter takes a column name directly: df &lt;- data.frame( y = 1, var = 2 ) df$y #&gt; [1] 1 var &lt;- &quot;y&quot; df[[var]] #&gt; [1] 1 Technically, [[ is an evaluating function while $ is a quoting function. You can indirectly refer to columns with [[ because the subsetting index is evaluated, allowing indirect references. The following expressions are completely equivalent: df[[var]] # Indirect #&gt; [1] 1 df[[&quot;y&quot;]] # Direct #&gt; [1] 1 But these are not: df$var # Direct #&gt; [1] 2 df$y # Direct #&gt; [1] 1 The following table summarises the fundamental asymmetry between the two subsetting methods: Quoted Evaluated Direct df$y df[[&quot;y&quot;]] Indirect ??? df[[var]] 4.1.2.2 Detecting quoting functions Because they work so differently to standard R code, it is important to recognise auto-quoted arguments. The documentation of the quoting function should normally tell you if an argument is quoted and evaluated in a special way. You can also detect quoted arguments by yourself with some experimentation. Let’s take the following expressions involving a mix of quoting and evaluating functions: library(MASS) #&gt; #&gt; 载入程辑包：&#39;MASS&#39; #&gt; The following object is masked from &#39;package:dplyr&#39;: #&gt; #&gt; select mtcars2 &lt;- subset(mtcars, cyl == 4) sum(mtcars2$am) #&gt; [1] 8 rm(mtcars2) A good indication that an argument is auto-quoted and evaluated in a special way is that the argument will not work correctly outside of its original context. Let’s try to break down each of these expressions in two steps by storing the arguments in an intermediary variable: library(MASS) temp &lt;- MASS #&gt; Error in eval(expr, envir, enclos): 找不到对象&#39;MASS&#39; temp &lt;- &quot;MASS&quot; library(temp) #&gt; Error in library(temp): 不存在叫&#39;temp&#39;这个名字的程辑包 We get these errors because there is no MASS object for R to find, and temp is interpreted by library() directly as a package name rather than as an indirect reference. Let’s try to break down the subset() expression: mtcars2 &lt;- subset(mtcars, cyl == 4) temp &lt;- cyl == 4 #&gt; Error in eval(expr, envir, enclos): 找不到对象&#39;cyl&#39; R cannot find cyl because we haven’t specified where to find it. This object exists only inside the mtcars data frame. sum(mtcars2$am) temp &lt;- mtcars$am sum(temp) #&gt; [1] 13 It worked! sum() is an evaluating function and the indirect reference was resolved in the ordinary way. rm(mtcars2) mtcars2 &lt;- mtcars temp &lt;- &quot;mtcars2&quot; rm(temp) exists(&quot;mtcars2&quot;) #&gt; [1] TRUE exists(&quot;temp&quot;) #&gt; [1] FALSE This time there was no error, but we have accidentally removed the variable temp instead of the variable it was referring to. This is because rm() auto-quotes its arguments. 4.1.3 Unquotation In practice, functions that evaluate their arguments are easier to program with because they support both direct and indirect references. For quoting functions, a piece of syntax is missing. We need the ability to unquote arguments. 4.1.3.1 Unquoting in base R Base R provides three different ways of allowing direct references: An extra function that evaluates its arguments. For instance the evaluating variant of the $ operator is [[. An extra parameter that switches off auto-quoting. For instance library() evaluates its first argument if you set character.only to TRUE: temp &lt;- &quot;MASS&quot; library(temp, character.only = TRUE) An extra parameter that evaluates its argument. If you have a list of object names to pass to rm(), use the list argument: temp &lt;- &quot;mtcars2&quot; rm(list = temp) exists(&quot;mtcars2&quot;) #&gt; [1] FALSE There is no general unquoting convention in base R so you have to read the documentation to figure out how to unquote an argument. Many functions like subset() or transform() do not provide any unquoting option at all. 4.1.3.2 Unquoting in the tidyverse!! All quoting functions in the tidyverse support a single unquotation mechanism, the !! operator (pronounced bang-bang). You can use !! to cancel the automatic quotation and supply indirect references everywhere an argument is automatically quoted. In other words, unquoting lets you open a variable and use what’s inside instead. First let’s create a couple of variables that hold references to columns from the mtcars data frame. A simple way of creating these references is to use the fundamental quoting function quote(): # Variables referring to columns `cyl` and `mpg` x_var &lt;- quote(cyl) y_var &lt;- quote(mpg) x_var #&gt; cyl y_var #&gt; mpg Here are a few examples of how !! can be used in tidyverse functions to unquote these variables, i.e. open them and use their contents. In dplyr most verbs quote their arguments: library(&quot;dplyr&quot;) by_cyl &lt;- mtcars %&gt;% group_by(!!x_var) %&gt;% # Open x_var summarise(mean = mean(!!y_var)) # Open y_var In ggplot2 aes() is the main quoting function: library(&quot;ggplot2&quot;) #&gt; Registered S3 methods overwritten by &#39;ggplot2&#39;: #&gt; method from #&gt; [.quosures rlang #&gt; c.quosures rlang #&gt; print.quosures rlang ggplot(mtcars, aes(!!x_var, !!y_var)) + # Open x_var and y_var geom_point() ggplot2 also features vars() which is useful for facetting: ggplot(mtcars, aes(disp, drat)) + geom_point() + facet_grid(vars(!!x_var)) # Open x_var Being able to make indirect references by opening variables with !! is rarely useful in scripts but is invaluable for writing functions. With !! we can now easily fix our wrapper function, as we’ll see in the following section. 4.1.4 Understanding !! with qq_show() At this point it is normal if the concept of unquoting still feels nebulous. A good way of practicing this operation is to see for yourself what it is really doing. To that end the qq_show() function from the rlang package performs unquoting and prints the result to the screen. Here is what !! is really doing in the dplyr example (I’ve broken the pipeline into two steps for readability): rlang::qq_show(mtcars %&gt;% group_by(!!x_var)) #&gt; mtcars %&gt;% group_by(cyl) rlang::qq_show(data %&gt;% summarise(mean = mean(!!y_var))) #&gt; data %&gt;% summarise(mean = mean(mpg)) Similarly for the ggplot2 pipeline: rlang::qq_show(ggplot(mtcars, aes(!!x_var, !!y_var))) #&gt; ggplot(mtcars, aes(cyl, mpg)) rlang::qq_show(facet_grid(vars(!!x_var))) #&gt; facet_grid(vars(cyl)) As you can see, unquoting a variable that contains a reference to the column cyl is equivalent to directly supplying cyl to the dplyr function. 4.2 Quote and unquote The basic process for creating tidyeval functions requires thinking a bit differently but is straightforward: quote and unquote. Use enquo() to make a function automatically quote its argument. Use !! to unquote the argument. Apart from these additional two steps, the process is the same. 4.2.1 The abstraction step We start as usual by identifying the varying parts of a computation and giving them informative names. These names become the arguments to the function. grouped_mean &lt;- function(data, group_var, summary_var) { data %&gt;% group_by(group_var) %&gt;% summarise(mean = mean(summary_var)) } As we have seen earlier this function does not quite work yet so let’s fix it by applying the two new steps. 4.2.2 The quoting step The quoting step is about making our ordinary function a quoting function. Not all parameters should be automatically quoted though. For instance the data argument refers to a real data frame that is passed around in the ordinary way. It is crucial to identify which parameters of your function should be automatically quoted: the parameters for which it is allowed to refer to columns in the data frames. In the example, group_var and summary_var are the parameters that refer to the data. We know that the fundamental quoting function is quote() but how do we go about creating other quoting functions? This is the job of enquo(). While quote() quotes what you typed, enquo() quotes what your user typed. In other words it makes an argument automatically quote its input. This is exactly how dplyr verbs are created! Here is how to apply enquo() to the group_var and summary_var arguments: group_var &lt;- enquo(group_var) summary_var &lt;- enquo(summary_var) 4.2.3 The unquoting step Finally we identify any place where these variables are passed to other quoting functions. That’s where we need to unquote with !!. In this case we pass group_var to group_by() and summary_var to summarise(): data %&gt;% group_by(!!group_var) %&gt;% summarise(mean = mean(!!summary_var)) 4.2.4 Result The finished function looks like this: grouped_mean &lt;- function(data, group_var, summary_var) { group_var &lt;- enquo(group_var) summary_var &lt;- enquo(summary_var) data %&gt;% group_by(!!group_var) %&gt;% summarise(mean = mean(!!summary_var)) } And voilà! grouped_mean(mtcars, cyl, mpg) #&gt; # A tibble: 3 x 2 #&gt; cyl mean #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 26.7 #&gt; 2 6 19.7 #&gt; 3 8 15.1 grouped_mean(mtcars, cyl, disp) #&gt; # A tibble: 3 x 2 #&gt; cyl mean #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 105. #&gt; 2 6 183. #&gt; 3 8 353. grouped_mean(mtcars, am, disp) #&gt; # A tibble: 2 x 2 #&gt; am mean #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 290. #&gt; 2 1 144. This simple quote-and-unquote pattern will get you a long way. It makes it possible to abstract complex combinations of quoting functions into a new quoting function. However this gets us in a sort of loop: quoting functions unquote inside other quoting functions and so on. At the start of the loop is the user typing expressions that are automatically quoted. But what if we can’t or don’t want to start with expressions typed by the user? What if we’d like to start with a character vector of column names? 4.3 Strings instead of quotes So far we have created a quoting function that wraps around other quoting functions. How can we break this chain of quoting? How can we go from the evaluating world to the quoting universe? The most common way this transition occurs is when you start with a character vector of column names and somehow need to pass the corresponding columns to quoting functions like dplyr::mutate(), dplyr::select(), or ggplot2::aes(). We need a way of bridging evaluating and quoting functions. First let’s see why simply unquoting strings does not work: var &lt;- &quot;height&quot; mutate(starwars, rescaled = !!var * 100) #&gt; Error in &quot;height&quot; * 100: 二进列运算符中有非数值参数 We get a type error. Observing the result of unquoting with qq_show() will shed some light on this: rlang::qq_show(mutate(starwars, rescaled = !!var * 100)) #&gt; mutate(starwars, rescaled = &quot;height&quot; * 100) We have unquoted a string, and now dplyr tried to multiply that string by 100! 4.3.1 Strings There is a fundamental difference between these two objects: &quot;height&quot; #&gt; [1] &quot;height&quot; quote(height) #&gt; height &quot;height&quot; is a string and quote(height) is a symbol, or variable name. A symbol is much more than a string, it is a reference to an R object. That’s why you have to use symbols to refer to data frame columns. Fortunately transforming strings to symbols is straightforward with the tidy eval sym() function: sym(&quot;height&quot;) #&gt; height If you use sym() instead of enquo(), you end up with an evaluating function that transforms its inputs into symbols that can suitably be unquoted: grouped_mean2 &lt;- function(data, group_var, summary_var) { group_var &lt;- sym(group_var) summary_var &lt;- sym(summary_var) data %&gt;% group_by(!!group_var) %&gt;% summarise(mean = mean(!!summary_var)) } With this simple change we now have an evaluating wrapper which can be used in the same way as [[. You can call grouped_mean2() with direct references: grouped_mean2(starwars, &quot;gender&quot;, &quot;mass&quot;) #&gt; # A tibble: 5 x 2 #&gt; gender mean #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 &lt;NA&gt; 46.3 #&gt; 2 female NA #&gt; 3 hermaphrodite 1358 #&gt; 4 male NA #&gt; 5 none NA Or indirect references: grp_var &lt;- &quot;gender&quot; sum_var &lt;- &quot;mass&quot; grouped_mean2(starwars, grp_var, sum_var) #&gt; # A tibble: 5 x 2 #&gt; gender mean #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 &lt;NA&gt; 46.3 #&gt; 2 female NA #&gt; 3 hermaphrodite 1358 #&gt; 4 male NA #&gt; 5 none NA 4.3.2 Character vectors of column names What if you have a whole character vector of column names? You can transform vectors to a list of symbols with the plural variant syms(): cols &lt;- syms(c(&quot;species&quot;, &quot;gender&quot;)) cols #&gt; [[1]] #&gt; species #&gt; #&gt; [[2]] #&gt; gender But now we have a list. Can we just unquote a list of symbols with !!? group_by(starwars, !!cols) #&gt; Error: Column `&lt;list&gt;` must be length 87 (the number of rows) or one, not 2 Something’s wrong. Using qq_show(), we see that group_by() gets a list instead of the individual symbols: rlang::qq_show(group_by(starwars, !!cols)) #&gt; group_by(starwars, &lt;list: species, gender&gt;) We should unquote each symbol in the list as a separate argument. The big bang operator !!! makes this easy: rlang::qq_show(group_by(starwars, !!cols[[1]], !!cols[[2]])) #&gt; group_by(starwars, species, gender) rlang::qq_show(group_by(starwars, !!!cols)) #&gt; group_by(starwars, species, gender) Working with multiple arguments and lists of expressions requires specific techniques such as using !!!. These techniques are covered in the next chapter. In practice this is a bit more complex because most quoting functions evaluate at least one argument, usually the data argument.↩ This is why regular functions are said to use standard evaluation unlike quoting functions which use non-standard evaluation (NSE). Note that the function is not entirely passive. Because arguments are lazily evaluated, the function gets to decide when an argument is evaluated, if at all.↩ "],
["multiple.html", "5 Dealing with multiple arguments 5.1 The ... argument 5.2 Simple forwarding of ... 5.3 Quote multiple arguments 5.4 Unquote multiple arguments", " 5 Dealing with multiple arguments In the first chapter we have created grouped_mean(), a function that takes one grouping variable and one summary variable and computes the grouped average. It would make sense to take multiple grouping variables instead of just one. Quoting and unquoting multiple variables is pretty much the same process as for single arguments: Unquoting multiple arguments requires a variant of !!, the big bang operator !!!. Quoting multiple arguments can be done in two ways: internal quoting with the plural variant enquos() and external quoting with vars(). 5.1 The ... argument The dot-dot-dot argument is one of the nicest aspects of the R language. A function that takes ... accepts any number of arguments, named or unnamed. As a programmer you can do three things with ...: Evaluate the arguments contained in the dots and materialise them in a list by forwarding the dots to list(): materialise &lt;- function(data, ...) { dots &lt;- list(...) dots } The dots names conveniently become the names of the list: materialise(mtcars, 1 + 2, important_name = letters) #&gt; [[1]] #&gt; [1] 3 #&gt; #&gt; $important_name #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; #&gt; [18] &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; Quote the arguments in the dots with enquos(): capture &lt;- function(data, ...) { dots &lt;- enquos(...) dots } All arguments passed to ... are automatically quoted and returned as a list. The names of the arguments become the names of that list: capture(mtcars, 1 + 2, important_name = letters) #&gt; &lt;list_of&lt;quosure&gt;&gt; #&gt; #&gt; [[1]] #&gt; &lt;quosure&gt; #&gt; expr: ^1 + 2 #&gt; env: global #&gt; #&gt; $important_name #&gt; &lt;quosure&gt; #&gt; expr: ^letters #&gt; env: global Forward the dots to another function: forward &lt;- function(data, ...) { forwardee(...) } When dots are forwarded the names of arguments in ... are matched to the arguments of the forwardee: forwardee &lt;- function(foo, bar, ...) { list(foo = foo, bar = bar, ...) } Let’s call the forwarding function with a bunch of named and unnamed arguments: forward(mtcars, bar = 100, 1, 2, 3) #&gt; $foo #&gt; [1] 1 #&gt; #&gt; $bar #&gt; [1] 100 #&gt; #&gt; [[3]] #&gt; [1] 2 #&gt; #&gt; [[4]] #&gt; [1] 3 The unnamed argument 1 was matched to foo positionally. The named argument bar was matched to bar. The remaining arguments were passed in order. For the purpose of writing tidy eval functions the last two techniques are important. There are two distinct situations: You don’t need to modify the arguments in any way, just passing them through. Then simply forward ... to other quoting functions in the ordinary way. You’d like to change the argument names (which become column names in dplyr::mutate() calls) or modify the arguments themselves (for instance negate a dplyr::select()ion). In that case you’ll need to use enquos() to quote the arguments in the dots. You’ll then pass the quoted arguments to other quoting functions by forwarding them with the help of !!!. 5.2 Simple forwarding of ... If you are not modifying the arguments in ... in any way and just want to pass them to another quoting function, just forward ... like usual! There is no need for quoting and unquoting because of the magic of forwarding. The arguments in ... are transported to their final destination where they will be quoted. The function grouped_mean() is still going to need some remodelling because it is good practice to take all important named arguments before the dots. Let’s start by swapping grouped_var and summary_var: grouped_mean &lt;- function(data, summary_var, group_var) { summary_var &lt;- enquo(summary_var) group_var &lt;- enquo(group_var) data %&gt;% group_by(!!group_var) %&gt;% summarise(mean = mean(!!summary_var)) } Then we replace group_var with ... and pass it to group_by(): grouped_mean &lt;- function(data, summary_var, ...) { summary_var &lt;- enquo(summary_var) data %&gt;% group_by(...) %&gt;% summarise(mean = mean(!!summary_var)) } It is good practice to make one final adjustment. Because arguments in ... can have arbitrary names, we don’t want to “use up” valid names. In tidyverse packages we use the convention of prefixing named arguments with a dot so that conflicts are less likely: grouped_mean &lt;- function(.data, .summary_var, ...) { .summary_var &lt;- enquo(.summary_var) .data %&gt;% group_by(...) %&gt;% summarise(mean = mean(!!.summary_var)) } Let’s check this function now works with any number of grouping variables: grouped_mean(mtcars, disp, cyl, am) #&gt; # A tibble: 6 x 3 #&gt; # Groups: cyl [3] #&gt; cyl am mean #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 0 136. #&gt; 2 4 1 93.6 #&gt; 3 6 0 205. #&gt; 4 6 1 155 #&gt; 5 8 0 358. #&gt; # … with 1 more row grouped_mean(mtcars, disp, cyl, am, vs) #&gt; # A tibble: 7 x 4 #&gt; # Groups: cyl, am [6] #&gt; cyl am vs mean #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 0 1 136. #&gt; 2 4 1 0 120. #&gt; 3 4 1 1 89.8 #&gt; 4 6 0 1 205. #&gt; 5 6 1 0 155 #&gt; # … with 2 more rows 5.3 Quote multiple arguments When we need to modify the arguments or their names, we can’t simply forward the dots. We’ll have to quote and unquote with the plural variants of enquo() and !!. We’ll quote the dots with enquos(). We’ll unquote-splice the quoted dots with !!!. While the singular enquo() returns a single quoted argument, the plural variant enquos() returns a list of quoted arguments. Let’s use it to quote the dots: grouped_mean2 &lt;- function(data, summary_var, ...) { summary_var &lt;- enquo(summary_var) group_vars &lt;- enquos(...) data %&gt;% group_by(!!group_vars) %&gt;% summarise(mean = mean(!!summary_var)) } grouped_mean() now accepts and automatically quotes any number of grouping variables. However it doesn’t work quite yet: FIXME: Depend on dev rlang to get a better error message. grouped_mean2(mtcars, disp, cyl, am) #&gt; Error: Column `&lt;S3: quosures&gt;` must be length 32 (the number of rows) or one, not 2 Instead of forwarding the individual arguments to group_by() we have passed the list of arguments itself! Unquoting is not the right operation here. Fortunately tidy eval provides a special operator that makes it easy to forward a list of arguments. 5.4 Unquote multiple arguments The unquote-splice operator !!! takes each element of a list and unquotes them as independent arguments to the surrounding function call. The arguments are spliced in the function call. This is just what we need for forwarding multiple quoted arguments. Let’s use qq_show() to observe the difference between !! and !!! in a group_by() expression. We can only use enquos() within a function so let’s create a list of quoted names for the purpose of experimenting: vars &lt;- list( quote(cyl), quote(am) ) qq_show() shows the difference between unquoting a list and unquote-splicing a list: rlang::qq_show(group_by(!!vars)) #&gt; group_by(&lt;list: cyl, am&gt;) rlang::qq_show(group_by(!!!vars)) #&gt; group_by(cyl, am) When we use the unquote operator !!, group_by() gets a list of expressions. When we unquote-splice with !!!, the expressions are forwarded as individual arguments to group_by(). Let’s use the latter to fix grouped_mean2(): grouped_mean2 &lt;- function(.data, .summary_var, ...) { summary_var &lt;- enquo(.summary_var) group_vars &lt;- enquos(...) .data %&gt;% group_by(!!!group_vars) %&gt;% summarise(mean = mean(!!summary_var)) } The quote and unquote version of grouped_mean() does a bit more work but is functionally identical to the forwarding version: grouped_mean(mtcars, disp, cyl, am) #&gt; # A tibble: 6 x 3 #&gt; # Groups: cyl [3] #&gt; cyl am mean #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 0 136. #&gt; 2 4 1 93.6 #&gt; 3 6 0 205. #&gt; 4 6 1 155 #&gt; 5 8 0 358. #&gt; # … with 1 more row grouped_mean2(mtcars, disp, cyl, am) #&gt; # A tibble: 6 x 3 #&gt; # Groups: cyl [3] #&gt; cyl am mean #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 0 136. #&gt; 2 4 1 93.6 #&gt; 3 6 0 205. #&gt; 4 6 1 155 #&gt; 5 8 0 358. #&gt; # … with 1 more row When does it become useful to do all this extra work? Whenever you need to modify the arguments or their names. Up to now we have used the quote-and-unquote pattern to pass quoted arguments to other quoting functions “as is”. With this simple and powerful pattern you can extract complex combinations of quoting verbs into reusable functions. However tidy eval provides much more flexibility. It is a general purpose meta-programming framework that makes it easy to modify quoted arguments before evaluation. In the next section you’ll learn about basic metaprogramming patterns that will allow you to modify expressions before passing them on to other functions. "],
["modifying-inputs.html", "6 Modifying inputs 6.1 Modifying names 6.2 Modifying quoted expressions", " 6 Modifying inputs With the quote-and-unquote pattern, quoted arguments are passed to other functions as is. In many cases you’ll find this to be too restrictive. This chapter will guide you through the steps required to pass custom argument names and custom quoted expressions. 6.1 Modifying names When your function creates new columns in a data frame it’s often a good idea to give them names that reflect the meaning of those columns. In this section you’ll learn how to: Create default names for quoted arguments. Unquote names. 6.1.1 Default argument names If you are familiar with dplyr you have probably noticed that new columns are given default names when you don’t supply one explictly to mutate() or summarise(). These default names are not practical for further manipulation but they are helpful to remind rushed users what their new column is about: starwars %&gt;% summarise(average = mean(height, na.rm = TRUE)) #&gt; # A tibble: 1 x 1 #&gt; average #&gt; &lt;dbl&gt; #&gt; 1 174. starwars %&gt;% summarise(mean(height, na.rm = TRUE)) #&gt; # A tibble: 1 x 1 #&gt; `mean(height, na.rm = TRUE)` #&gt; &lt;dbl&gt; #&gt; 1 174. You can create default names by applying quo_name() to any expressions: var1 &lt;- quote(height) var2 &lt;- quote(mean(height)) quo_name(var1) #&gt; [1] &quot;height&quot; quo_name(var2) #&gt; [1] &quot;mean(height)&quot; Including automatically quoted arguments: arg_name &lt;- function(var) { var &lt;- enquo(var) quo_name(var) } arg_name(height) #&gt; [1] &quot;height&quot; arg_name(mean(height)) #&gt; [1] &quot;mean(height)&quot; Lists of quoted expressions require a different approach because we don’t want to override user-supplied names. The easiest way is to call enquos() with .named = TRUE. With this option, all unnamed arguments get a default name: args_names &lt;- function(...) { vars &lt;- enquos(..., .named = TRUE) names(vars) } args_names(mean(height), weight) #&gt; [1] &quot;mean(height)&quot; &quot;weight&quot; args_names(avg = mean(height), weight) #&gt; [1] &quot;avg&quot; &quot;weight&quot; 6.1.2 Unquoting argument names Argument names are one of the most common occurrence of quotation in R. There is no fundamental difference between these two ways of creating a &quot;myname&quot; string: names(c(Mickey = NA)) #&gt; [1] &quot;Mickey&quot; quo_name(quote(Mickey)) #&gt; [1] &quot;Mickey&quot; Where there is quotation it is natural to have unquotation. For this reason, tidy eval makes it possible to use !! to unquote names. Unfortunately we’ll have to use a somewhat peculiar syntax to unquote names because using complex expressions on the left-hand side of = is not valid R code: nm &lt;- &quot;Mickey&quot; args_names(!!nm = 1) #&gt; Error: &lt;text&gt;:2:17: 意外的&#39;=&#39; #&gt; 1: nm &lt;- &quot;Mickey&quot; #&gt; 2: args_names(!!nm = #&gt; ^ Instead you’ll have to unquote of the LHS of :=. This vestigial operator is interpreted by tidy eval functions in exactly the same way as = but with !! support: nm &lt;- &quot;Mickey&quot; args_names(!!nm := 1) #&gt; [1] &quot;Mickey&quot; Another way of achieving the same result is to splice a named list of arguments: args &lt;- setNames(list(1), nm) args_names(!!!args) #&gt; [1] &quot;Mickey&quot; This works because !!! uses the names of the list as argument names. This is a great pattern when you are dealing with multiple arguments: nms &lt;- c(&quot;Mickey&quot;, &quot;Minnie&quot;) args &lt;- setNames(list(1, 2), nms) args_names(!!!args) #&gt; [1] &quot;Mickey&quot; &quot;Minnie&quot; 6.1.3 Prefixing quoted arguments Now that we know how to unquote argument, let’s apply informative prefixes to the names of the columns created in grouped_mean(). We’ll start with the summary variable: Get the default name of the quoted summary variable. Prepend it with a prefix. Unquote it with !! and :=. grouped_mean2 &lt;- function(.data, .summary_var, ...) { summary_var &lt;- enquo(.summary_var) group_vars &lt;- enquos(...) # Get and modify the default name summary_nm &lt;- quo_name(summary_var) summary_nm &lt;- paste0(&quot;avg_&quot;, summary_nm) .data %&gt;% group_by(!!!group_vars) %&gt;% summarise(!!summary_nm := mean(!!summary_var)) # Unquote the name } grouped_mean2(mtcars, disp, cyl, am) #&gt; # A tibble: 6 x 3 #&gt; # Groups: cyl [3] #&gt; cyl am avg_disp #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 0 136. #&gt; 2 4 1 93.6 #&gt; 3 6 0 205. #&gt; 4 6 1 155 #&gt; 5 8 0 358. #&gt; # … with 1 more row names(grouped_mean2(mtcars, disp, cyl, am)) #&gt; [1] &quot;cyl&quot; &quot;am&quot; &quot;avg_disp&quot; Regarding the grouping variables, this is a case where explictly quoting and unquoting ... pays off because we need to change the names of the list of quoted dots: Give default names to quoted dots with .named = TRUE. Prepend the names of the list with a prefix. Unquote-splice the list of quoted arguments as usual. grouped_mean2 &lt;- function(.data, .summary_var, ...) { summary_var &lt;- enquo(.summary_var) # Quote the dots with default names group_vars &lt;- enquos(..., .named = TRUE) summary_nm &lt;- quo_name(summary_var) summary_nm &lt;- paste0(&quot;avg_&quot;, summary_nm) # Modify the names of the list of quoted dots names(group_vars) &lt;- paste0(&quot;groups_&quot;, names(group_vars)) .data %&gt;% group_by(!!!group_vars) %&gt;% # Unquote-splice as usual summarise(!!summary_nm := mean(!!summary_var)) } grouped_mean2(mtcars, disp, cyl, am) #&gt; # A tibble: 6 x 3 #&gt; # Groups: groups_cyl [3] #&gt; groups_cyl groups_am avg_disp #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 0 136. #&gt; 2 4 1 93.6 #&gt; 3 6 0 205. #&gt; 4 6 1 155 #&gt; 5 8 0 358. #&gt; # … with 1 more row names(grouped_mean2(mtcars, disp, cyl, am)) #&gt; [1] &quot;groups_cyl&quot; &quot;groups_am&quot; &quot;avg_disp&quot; 6.2 Modifying quoted expressions The quote-and-unquote pattern is a powerful and versatile technique. In this section we’ll use it for modifying quoted arguments. In dealing with multiple arguments, we have created a version of grouped_mean() that takes multiple grouping variables. Say we would like to take multiple summary variables instead. We could start by replacing summary_var with the ... argument: grouped_mean3 &lt;- function(.data, .group_var, ...) { group_var &lt;- enquo(.group_var) summary_vars &lt;- enquos(..., .named = TRUE) .data %&gt;% group_by(!!group_var) %&gt;% summarise(!!!summary_vars) # How do we take the mean? } The quoting part is easy. But how do we go about taking the average of each argument before passing them on to summarise()? We’ll have to modify the list of summary variables. 6.2.1 Expanding quoted expressions with expr() Quoting and unquoting is an effective technique for modifying quoted expressions. But we’ll need to add one more function to our toolbox to work around the lack of unquoting support in quote(). As we saw, the fundamental quoting function in R is quote(). All it does is return its quoted argument: quote(mean(mass)) #&gt; mean(mass) quote() does not support quasiquotation but tidy eval provides a variant that does. With expr(), you can quote expressions with full unquoting support: vars &lt;- list(quote(mass), quote(height)) expr(mean(!!vars[[1]])) #&gt; mean(mass) expr(group_by(!!!vars)) #&gt; group_by(mass, height) Note what just happened: by quoting-and-unquoting, we have expanded existing quoted expressions! This is the key to modifying expressions before passing them on to other quoting functions. For instance we could loop over the summary variables and unquote each of them in a mean() expression: purrr::map(vars, function(var) expr(mean(!!var, na.rm = TRUE))) #&gt; [[1]] #&gt; mean(mass, na.rm = TRUE) #&gt; #&gt; [[2]] #&gt; mean(height, na.rm = TRUE) Let’s fix grouped_mean3() using this pattern: grouped_mean3 &lt;- function(.data, .group_var, ...) { group_var &lt;- enquo(.group_var) summary_vars &lt;- enquos(..., .named = TRUE) # Wrap the summary variables with mean() summary_vars &lt;- purrr::map(summary_vars, function(var) { expr(mean(!!var, na.rm = TRUE)) }) # Prefix the names with `avg_` names(summary_vars) &lt;- paste0(&quot;avg_&quot;, names(summary_vars)) .data %&gt;% group_by(!!group_var) %&gt;% summarise(!!!summary_vars) } grouped_mean3(starwars, species, height) #&gt; # A tibble: 38 x 2 #&gt; species avg_height #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 &lt;NA&gt; 160 #&gt; 2 Aleena 79 #&gt; 3 Besalisk 198 #&gt; 4 Cerean 198 #&gt; 5 Chagrian 196 #&gt; # … with 33 more rows grouped_mean3(starwars, species, height, mass) #&gt; # A tibble: 38 x 3 #&gt; species avg_height avg_mass #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 &lt;NA&gt; 160 48 #&gt; 2 Aleena 79 15 #&gt; 3 Besalisk 198 102 #&gt; 4 Cerean 198 82 #&gt; 5 Chagrian 196 NaN #&gt; # … with 33 more rows "],
["glossary.html", "7 Glossary 7.1 Data structures 7.2 Programming Concepts", " 7 Glossary This glossary contains the vocabulary necessary to work with tidy evaluation and, more generally, with expressions. The definitions in rlang are generally consistent with base R. When they differ, both definitions are presented so you can navigate between these two worlds more easily. 7.1 Data structures 7.1.1 TODO Data mask 7.1.2 Expression An expression is a piece of R code that represents a value or a computation: 12 # Value 12 / 3 # Computation 12 / (1 + 2) # Nested computations Expressions are normally transient. They are computed (or evaluated) when you source a file or call a function. You can only observe: The final value of the outermost expression. Their side effects, such as the console output of a print() expression inside a loop. In R however, it is possible to suspend the normal evaluation of expressions with the quotation mechanism. In a way, quotation causes expressions to freeze in place: # Evaluated expression 12 / 3 #&gt; [1] 4 # Quoted expression expr(12 / 3) #&gt; 12/3 The technical definition of expressions is any R object that is created by parsing R code: Constants like NULL, 1, &quot;foo&quot;, TRUE, NA, etc. Symbols like height or weight Calls like c() or list() Unlike constants, symbols and calls are symbolic objects: their value depends on the environment. 7.1.3 Expression (base) In base R, “expression” refers to a special type of vector that contains quoted expressions in the rlang sense: base::expression(key &lt;- &quot;foo&quot;, toupper(key)) #&gt; expression(key &lt;- &quot;foo&quot;, toupper(key)) You’ll most likely encounter this rare data structure as the return value of base::parse(): code &lt;- &quot;key &lt;- &#39;foo&#39;; toupper(key)&quot; parse(text = code) #&gt; expression(key &lt;- &quot;foo&quot;, toupper(key)) The only advantage of expression vectors compared to lists is that they include source references. Expression vectors with source references are printed with whitespace and comments preserved: code &lt;- &quot;{ # Interesting comment weird &lt;- whitespace }&quot; parse(text = code, keep.source = TRUE) #&gt; expression({ #&gt; # Interesting comment #&gt; weird &lt;- whitespace #&gt; }) Source references are mostly useful for debugging and development tools. They don’t play any computational role and tidy evaluation doesn’t make use of references. Consequently the parsing tools in rlang return normal lists of expressions (in the rlang sense) instead of expression vectors: rlang::parse_exprs(code) #&gt; [[1]] #&gt; { #&gt; weird &lt;- whitespace #&gt; } 7.1.4 TODO Symbol 7.2 Programming Concepts 7.2.1 Constant versus symbolic Constants, also called “literals”, always have the same value no matter the context. On the other hand, symbols and calls are symbolic expressions: their value depends on an environment and what kind of objects are defined there. For instance the string &quot;mickey&quot; always represents the same string no matter the environment and what objects are defined there: # Here&#39;s a string: &quot;mickey&quot; #&gt; [1] &quot;mickey&quot; mickey &lt;- &quot;mouse&quot; # Still the same string: &quot;mickey&quot; #&gt; [1] &quot;mickey&quot; In constrast, symbols depend on current definitions: # We&#39;ve defined `mickey` as &quot;mouse&quot; mickey #&gt; [1] &quot;mouse&quot; mickey &lt;- &quot;mickey&quot; # Now `mickey` is &quot;mickey&quot; mickey #&gt; [1] &quot;mickey&quot; One source of problems when you’re working with quoted expressions is that they might be evaluated in arbitrary places, where objects have potentially been redefined to something different than expected. This is a common issue with tidyverse grammars because they evaluate quoted expressions in a data mask. Say you’d like to divide a column by a factor defined in the current environment: factor &lt;- 100 starwars %&gt;% mutate(height / factor) %&gt;% pull() #&gt; [1] 1.72 1.67 0.96 2.02 1.50 1.78 1.65 0.97 1.83 1.82 1.88 1.80 2.28 1.80 #&gt; [15] 1.73 1.75 1.70 1.80 0.66 1.70 1.83 2.00 1.90 1.77 1.75 1.80 1.50 NA #&gt; [29] 0.88 1.60 1.93 1.91 1.70 1.96 2.24 2.06 1.83 1.37 1.12 1.83 1.63 1.75 #&gt; [43] 1.80 1.78 0.94 1.22 1.63 1.88 1.98 1.96 1.71 1.84 1.88 2.64 1.88 1.96 #&gt; [57] 1.85 1.57 1.83 1.83 1.70 1.66 1.65 1.93 1.91 1.83 1.68 1.98 2.29 2.13 #&gt; [71] 1.67 0.79 0.96 1.93 1.91 1.78 2.16 2.34 1.88 1.78 2.06 NA NA NA #&gt; [85] NA NA 1.65 This works fine but what if the data frame contains a column called factor? The expression will be evaluated with the parasite definition: # Derive a data frame that contains a `factor` column starwars2 &lt;- starwars %&gt;% mutate(factor = 1:n()) # Oh no! We&#39;re now dividing `height` by the new column! starwars2 %&gt;% mutate(height / factor) %&gt;% pull() #&gt; [1] 172.0 83.5 32.0 50.5 30.0 29.7 23.6 12.1 20.3 18.2 17.1 #&gt; [12] 15.0 17.5 12.9 11.5 10.9 10.0 10.0 3.5 8.5 8.7 9.1 #&gt; [23] 8.3 7.4 7.0 6.9 5.6 NA 3.0 5.3 6.2 6.0 5.2 #&gt; [34] 5.8 6.4 5.7 4.9 3.6 2.9 4.6 4.0 4.2 4.2 4.0 #&gt; [45] 2.1 2.7 3.5 3.9 4.0 3.9 3.4 3.5 3.5 4.9 3.4 #&gt; [56] 3.5 3.2 2.7 3.1 3.0 2.8 2.7 2.6 3.0 2.9 2.8 #&gt; [67] 2.5 2.9 3.3 3.0 2.4 1.1 1.3 2.6 2.5 2.3 2.8 #&gt; [78] 3.0 2.4 2.2 2.5 NA NA NA NA NA 1.9 Masking is generally not a problem in scripts because you know what columns are inside your data frame. However as soon as your code is getting more general, for instance if you create a reusable function, you can no longer make assumptions about what’s in the data. Fortunately with quasiquotation it is easy to solve masking issues by replacing symbols with constants. The unquoting operator !! allows you to inline constant values deep inside expressions. With qq_show() we can observe the inlining: vector &lt;- 1:3 # Without inlining, the expression depends on the value of `vector`: rlang::qq_show(list(vector)) #&gt; list(vector) # Let&#39;s inline the current value of `vector` by unquoting it: rlang::qq_show(list(!!vector)) #&gt; list(&lt;int: 1L, 2L, 3L&gt;) Because constants have the same value in any environment, the data mask can never take over with parasite definitions: rlang::qq_show(starwars2 %&gt;% mutate(height / !!factor) %&gt;% pull()) #&gt; starwars2 %&gt;% mutate(height / 100) %&gt;% pull() starwars2 %&gt;% mutate(height / !!factor) %&gt;% pull() #&gt; [1] 1.72 1.67 0.96 2.02 1.50 1.78 1.65 0.97 1.83 1.82 1.88 1.80 2.28 1.80 #&gt; [15] 1.73 1.75 1.70 1.80 0.66 1.70 1.83 2.00 1.90 1.77 1.75 1.80 1.50 NA #&gt; [29] 0.88 1.60 1.93 1.91 1.70 1.96 2.24 2.06 1.83 1.37 1.12 1.83 1.63 1.75 #&gt; [43] 1.80 1.78 0.94 1.22 1.63 1.88 1.98 1.96 1.71 1.84 1.88 2.64 1.88 1.96 #&gt; [57] 1.85 1.57 1.83 1.83 1.70 1.66 1.65 1.93 1.91 1.83 1.68 1.98 2.29 2.13 #&gt; [71] 1.67 0.79 0.96 1.93 1.91 1.78 2.16 2.34 1.88 1.78 2.06 NA NA NA #&gt; [85] NA NA 1.65 7.2.2 TODO Non-Standard Evaluation (NSE) 7.2.3 TODO Quotation versus Evaluation 7.2.4 TODO Quasiquotation 7.2.5 TODO Parsing 7.2.6 TODO Metaprogramming "],
["dplyr.html", "8 dplyr 8.1 Patterns for single arguments 8.2 Patterns for multiple arguments 8.3 select() 8.4 filter() 8.5 case_when() 8.6 Gotchas", " 8 dplyr In the introductory vignette we learned that creating tidy eval functions boils down to a single pattern: quote and unquote. In this vignette we’ll apply this pattern in a series of recipes for dplyr. This vignette is organised so that you can quickly find your way to a copy-paste solution when you face an immediate problem. 8.1 Patterns for single arguments 8.1.1 enquo() and !! - Quote and unquote arguments We start with a quick recap of the introductory vignette. Creating a function around dplyr pipelines involves three steps: abstraction, quoting, and unquoting. Abstraction step First identify the varying parts: df1 %&gt;% group_by(x1) %&gt;% summarise(mean = mean(y1)) df2 %&gt;% group_by(x2) %&gt;% summarise(mean = mean(y2)) df3 %&gt;% group_by(x3) %&gt;% summarise(mean = mean(y3)) df4 %&gt;% group_by(x4) %&gt;% summarise(mean = mean(y4)) And abstract those away with a informative argument names: data %&gt;% group_by(group_var) %&gt;% summarise(mean = mean(summary_var)) And wrap in a function: grouped_mean &lt;- function(data, group_var, summary_var) { data %&gt;% group_by(group_var) %&gt;% summarise(mean = mean(summary_var)) } Quoting step Identify all the arguments where the user is allowed to refer to data frame columns directly. The function can’t evaluate these arguments right away. Instead they should be automatically quoted. Apply enquo() to these arguments group_var &lt;- enquo(group_var) summary_var &lt;- enquo(summary_var) Unquoting step Identify where these variables are passed to other quoting functions and unquote with !!. In this case we pass group_var to group_by() and summary_var to summarise(): data %&gt;% group_by(!!group_var) %&gt;% summarise(mean = mean(!!summary_var)) We end up with a function that automatically quotes its arguments group_var and summary_var and unquotes them when they are passed to other quoting functions: grouped_mean &lt;- function(data, group_var, summary_var) { group_var &lt;- enquo(group_var) summary_var &lt;- enquo(summary_var) data %&gt;% group_by(!!group_var) %&gt;% summarise(mean = mean(!!summary_var)) } grouped_mean(mtcars, cyl, mpg) #&gt; # A tibble: 3 x 2 #&gt; cyl mean #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 26.7 #&gt; 2 6 19.7 #&gt; 3 8 15.1 8.1.2 quo_name() - Create default column names Use quo_name() to transform a quoted expression to a column name: simple_var &lt;- quote(height) quo_name(simple_var) #&gt; [1] &quot;height&quot; These names are only a default stopgap. For more complex uses, you’ll probably want to let the user override the default. Here is a case where the default name is clearly suboptimal: complex_var &lt;- quote(mean(height, na.rm = TRUE)) quo_name(complex_var) #&gt; [1] &quot;mean(height, na.rm = TRUE)&quot; 8.1.3 := and !! - Unquote column names In expressions like c(name = NA), the argument name is quoted. Because of the quoting it’s not possible to make an indirect reference to a variable that contains a name: name &lt;- &quot;the real name&quot; c(name = NA) #&gt; name #&gt; NA In tidy eval function it is possible to unquote argument names with !!. However you need the special := operator: rlang::qq_show(c(!!name := NA)) #&gt; c(&quot;the real name&quot; := NA) This unusual operator is needed because using ! on the left-hand side of = is not valid R code: rlang::qq_show(c(!!name = NA)) #&gt; Error: &lt;text&gt;:1:25: 意外的&#39;=&#39; #&gt; 1: rlang::qq_show(c(!!name = #&gt; ^ Let’s use this !! technique to pass custom column names to group_by() and summarise(): grouped_mean &lt;- function(data, group_var, summary_var) { group_var &lt;- enquo(group_var) summary_var &lt;- enquo(summary_var) # Create default column names group_nm &lt;- quo_name(group_var) summary_nm &lt;- quo_name(summary_var) # Prepend with an informative prefix group_nm &lt;- paste0(&quot;group_&quot;, group_nm) summary_nm &lt;- paste0(&quot;mean_&quot;, summary_nm) data %&gt;% group_by(!!group_nm := !!group_var) %&gt;% summarise(!!summary_nm := mean(!!summary_var)) } grouped_mean(mtcars, cyl, mpg) #&gt; # A tibble: 3 x 2 #&gt; group_cyl mean_mpg #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 26.7 #&gt; 2 6 19.7 #&gt; 3 8 15.1 8.2 Patterns for multiple arguments 8.2.1 ... - Forward multiple arguments We have created a function that takes one grouping variable and one summary variable. It would make sense to take multiple grouping variables instead of just one. Let’s adjust our function with a ... argument. Replace group_var by ...: function(data, ..., summary_var) Swap ... and summary_var because arguments on the right-hand side of ... are harder to pass. They can only be passed with their full name explictly specified while arguments on the left-hand side can be passed without name: function(data, summary_var, ...) It’s good practice to prefix named arguments with a . to reduce the risk of conflicts between your arguments and the arguments passed to ...: function(.data, .summary_var, ...) Because of the magic of dots forwarding we don’t have to use the quote-and-unquote pattern. We can just pass ... to other quoting functions like group_by(): grouped_mean &lt;- function(.data, .summary_var, ...) { summary_var &lt;- enquo(.summary_var) .data %&gt;% group_by(...) %&gt;% # Forward `...` summarise(mean = mean(!!summary_var)) } grouped_mean(mtcars, disp, cyl, am) #&gt; # A tibble: 6 x 3 #&gt; # Groups: cyl [3] #&gt; cyl am mean #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 0 136. #&gt; 2 4 1 93.6 #&gt; 3 6 0 205. #&gt; 4 6 1 155 #&gt; 5 8 0 358. #&gt; # … with 1 more row Forwarding ... is straightforward but has the downside that you can’t modify the arguments or their names. 8.2.2 enquos() and !!! - Quote and unquote multiple arguments Quoting and unquoting multiple variables with ... is pretty much the same process as for single arguments: Quoting multiple arguments can be done in two ways: internal quoting with the plural variant enquos() and external quoting with vars(). Use internal quoting when your function takes expressions with ... and external quoting when your function takes a list of expressions. Unquoting multiple arguments requires a variant of !!, the unquote-splice operator !!! which unquotes each element of a list as an independent argument in the surrounding function call. Quote the dots with enquos() and unquote-splice them with !!!: grouped_mean2 &lt;- function(.data, .summary_var, ...) { summary_var &lt;- enquo(.summary_var) group_vars &lt;- enquos(...) # Get a list of quoted dots .data %&gt;% group_by(!!!group_vars) %&gt;% # Unquote-splice the list summarise(mean = mean(!!summary_var)) } grouped_mean2(mtcars, disp, cyl, am) #&gt; # A tibble: 6 x 3 #&gt; # Groups: cyl [3] #&gt; cyl am mean #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 0 136. #&gt; 2 4 1 93.6 #&gt; 3 6 0 205. #&gt; 4 6 1 155 #&gt; 5 8 0 358. #&gt; # … with 1 more row The quote-and-unquote pattern does more work than simple forwarding of ... and is functionally identical. Don’t do this extra work unless you need to modify the arguments or their names. 8.2.3 expr() - Modify quoted arguments Modifying quoted expressions is often necessary when dealing with multiple arguments. Say we’d like a grouped_mean() variant that takes multiple summary variables rather than multiple grouping variables. We need to somehow take the mean() of each summary variable. One easy way is to use the quote-and-unquote pattern with expr(). This function is just like quote() from base R. It plainly returns your argument, quoted: quote(height) #&gt; height expr(height) #&gt; height quote(mean(height)) #&gt; mean(height) expr(mean(height)) #&gt; mean(height) But expr() has a twist, it has full unquoting support: vars &lt;- list(quote(height), quote(mass)) expr(mean(!!vars[[1]])) #&gt; mean(height) expr(group_by(!!!vars)) #&gt; group_by(height, mass) You can loop over a list of arguments and modify each of them: purrr::map(vars, function(var) expr(mean(!!var, na.rm = TRUE))) #&gt; [[1]] #&gt; mean(height, na.rm = TRUE) #&gt; #&gt; [[2]] #&gt; mean(mass, na.rm = TRUE) This makes it easy to take multiple summary variables, wrap them in a call to mean(), before unquote-splicing within summarise(): grouped_mean3 &lt;- function(.data, .group_var, ...) { group_var &lt;- enquo(.group_var) summary_vars &lt;- enquos(...) # Get a list of quoted summary variables summary_vars &lt;- purrr::map(summary_vars, function(var) { expr(mean(!!var, na.rm = TRUE)) }) .data %&gt;% group_by(!!group_var) %&gt;% summarise(!!!summary_vars) # Unquote-splice the list } 8.2.4 vars() - Quote multiple arguments externally How could we take multiple summary variables in addition to multiple grouping variables? Internal quoting with ... has a major disadvantage: the arguments in ... can only have one purpose. If you need to quote multiple sets of variables you have to delegate the quoting to another function. That’s the purpose of vars() which quotes its arguments and returns a list: vars(species, gender) #&gt; &lt;list_of&lt;quosure&gt;&gt; #&gt; #&gt; [[1]] #&gt; &lt;quosure&gt; #&gt; expr: ^species #&gt; env: global #&gt; #&gt; [[2]] #&gt; &lt;quosure&gt; #&gt; expr: ^gender #&gt; env: global The arguments can be complex expressions and have names: vars(h = height, m = mass / 100) #&gt; &lt;list_of&lt;quosure&gt;&gt; #&gt; #&gt; $h #&gt; &lt;quosure&gt; #&gt; expr: ^height #&gt; env: global #&gt; #&gt; $m #&gt; &lt;quosure&gt; #&gt; expr: ^mass / 100 #&gt; env: global When the quoting is external you don’t use enquos(). Simply take lists of expressions in your function and forward the lists to other quoting functions with !!!: grouped_mean3 &lt;- function(data, group_vars, summary_vars) { stopifnot( is.list(group_vars), is.list(summary_vars) ) summary_vars &lt;- purrr::map(summary_vars, function(var) { expr(mean(!!var, na.rm = TRUE)) }) data %&gt;% group_by(!!!group_vars) %&gt;% summarise(n = n(), !!!summary_vars) } grouped_mean3(starwars, vars(species, gender), vars(height)) #&gt; # A tibble: 43 x 4 #&gt; # Groups: species [38] #&gt; species gender n `mean(height, na.rm = TRUE)` #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 &lt;NA&gt; female 3 137 #&gt; 2 &lt;NA&gt; male 2 183 #&gt; 3 Aleena male 1 79 #&gt; 4 Besalisk male 1 198 #&gt; 5 Cerean male 1 198 #&gt; # … with 38 more rows grouped_mean3(starwars, vars(gender), vars(height, mass)) #&gt; # A tibble: 5 x 4 #&gt; gender n `mean(height, na.rm = TRUE… `mean(mass, na.rm = TRUE… #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 &lt;NA&gt; 3 120 46.3 #&gt; 2 female 19 165. 54.0 #&gt; 3 hermaphrodite 1 175 1358 #&gt; 4 male 62 179. 81.0 #&gt; 5 none 2 200 140 One advantage of vars() is that it lets users specify their own names: grouped_mean3(starwars, vars(gender), vars(h = height, m = mass)) #&gt; # A tibble: 5 x 4 #&gt; gender n h m #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 &lt;NA&gt; 3 120 46.3 #&gt; 2 female 19 165. 54.0 #&gt; 3 hermaphrodite 1 175 1358 #&gt; 4 male 62 179. 81.0 #&gt; 5 none 2 200 140 8.2.5 enquos(.named = TRUE) - Automatically add default names If you pass .named = TRUE to enquos() the unnamed expressions are automatically given default names: f &lt;- function(...) names(enquos(..., .named = TRUE)) f(height, mean(mass)) #&gt; [1] &quot;height&quot; &quot;mean(mass)&quot; User-supplied names are never overridden: f(height, m = mean(mass)) #&gt; [1] &quot;height&quot; &quot;m&quot; This is handy when you need to modify the names of quoted expressions. In this example we’ll ensure the list is named before adding a prefix: grouped_mean2 &lt;- function(.data, .summary_var, ...) { summary_var &lt;- enquo(.summary_var) group_vars &lt;- enquos(..., .named = TRUE) # Ensure quoted dots are named # Prefix the names of the list of quoted dots names(group_vars) &lt;- paste0(&quot;group_&quot;, names(group_vars)) .data %&gt;% group_by(!!!group_vars) %&gt;% # Unquote-splice the list summarise(mean = mean(!!summary_var)) } grouped_mean2(mtcars, disp, cyl, am) #&gt; # A tibble: 6 x 3 #&gt; # Groups: group_cyl [3] #&gt; group_cyl group_am mean #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 0 136. #&gt; 2 4 1 93.6 #&gt; 3 6 0 205. #&gt; 4 6 1 155 #&gt; 5 8 0 358. #&gt; # … with 1 more row One big downside of this technique is that all arguments get a prefix, including the arguments that were given specific names by the user: grouped_mean2(mtcars, disp, c = cyl, a = am) #&gt; # A tibble: 6 x 3 #&gt; # Groups: group_c [3] #&gt; group_c group_a mean #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 0 136. #&gt; 2 4 1 93.6 #&gt; 3 6 0 205. #&gt; 4 6 1 155 #&gt; 5 8 0 358. #&gt; # … with 1 more row In general it’s better to preserve the names explicitly passed by the user. To do that we can’t automatically add default names with enquos() because once the list is fully named we don’t have any way of detecting which arguments were passed with an explicit names. We’ll have to add default names manually with quos_auto_name(). 8.2.6 quos_auto_name() - Manually add default names It can be helpful add default names to the list of quoted dots manually: We can detect which arguments were explicitly named by the user. The default names can be applied to lists returned by vars(). Let’s add default names manually with quos_auto_name() to lists of externally quoted variables. We’ll detect unnamed arguments and only add a prefix to this subset of arguments. This way we preserve user-supplied names: grouped_mean3 &lt;- function(data, group_vars, summary_vars) { stopifnot( is.list(group_vars), is.list(summary_vars) ) # Detect and prefix unnamed arguments: unnamed &lt;- names(summary_vars) == &quot;&quot; # Add the default names: summary_vars &lt;- rlang::quos_auto_name(summary_vars) prefixed_nms &lt;- paste0(&quot;mean_&quot;, names(summary_vars)[unnamed]) names(summary_vars)[unnamed] &lt;- prefixed_nms # Expand the argument _after_ giving the list its default names summary_vars &lt;- purrr::map(summary_vars, function(var) { expr(mean(!!var, na.rm = TRUE)) }) data %&gt;% group_by(!!!group_vars) %&gt;% summarise(n = n(), !!!summary_vars) # Unquote-splice the renamed list } Note how we add the default names before wrapping the arguments in a mean() call. This way we avoid including mean() in the name: quo_name(quote(mass)) #&gt; [1] &quot;mass&quot; quo_name(quote(mean(mass, na.rm = TRUE))) #&gt; [1] &quot;mean(mass, na.rm = TRUE)&quot; We get nicely prefixed default names: grouped_mean3(starwars, vars(gender), vars(height, mass)) #&gt; # A tibble: 5 x 4 #&gt; gender n mean_height mean_mass #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 &lt;NA&gt; 3 120 46.3 #&gt; 2 female 19 165. 54.0 #&gt; 3 hermaphrodite 1 175 1358 #&gt; 4 male 62 179. 81.0 #&gt; 5 none 2 200 140 And the user is able to fully override the names: grouped_mean3(starwars, vars(gender), vars(h = height, m = mass)) #&gt; # A tibble: 5 x 4 #&gt; gender n h m #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 &lt;NA&gt; 3 120 46.3 #&gt; 2 female 19 165. 54.0 #&gt; 3 hermaphrodite 1 175 1358 #&gt; 4 male 62 179. 81.0 #&gt; 5 none 2 200 140 8.3 select() TODO 8.4 filter() TODO 8.5 case_when() TODO 8.6 Gotchas 8.6.1 Nested quoting functions https://stackoverflow.com/questions/51902438/rlangsym-in-anonymous-functions "],
["ggplot2.html", "9 ggplot2", " 9 ggplot2 "],
["a-rich-toolbox.html", "10 A rich toolbox 10.1 TODO quote(), expr() and enexpr() 10.2 TODO quo() and enquo() 10.3 TODO vars(), quos() and enquos() 10.4 TODO qq_show() 10.5 TODO sym() and syms()", " 10 A rich toolbox 10.1 TODO quote(), expr() and enexpr() case_when() example? 10.2 TODO quo() and enquo() 10.3 TODO vars(), quos() and enquos() Is it confusing that vars() is an alias of quos()? 10.4 TODO qq_show() 10.5 TODO sym() and syms() "],
["creating-grammars.html", "11 Creating grammars", " 11 Creating grammars "]
]
